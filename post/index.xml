<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 临风博客</title>
    <link>https://jordonyang.github.io/post/</link>
    <description>Recent content in Posts on 临风博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh_CN</language>
    <copyright>All rights reserved</copyright>
    <lastBuildDate>Thu, 18 Oct 2018 22:23:44 +0800</lastBuildDate>
    
	<atom:link href="https://jordonyang.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>AES加密算法原理及实现</title>
      <link>https://jordonyang.github.io/post/impl-of-aes/</link>
      <pubDate>Thu, 18 Oct 2018 22:23:44 +0800</pubDate>
      
      <guid>https://jordonyang.github.io/post/impl-of-aes/</guid>
      <description>一、概述 美国政府在1997年9月12日公开征集更高效更安全的替代DES加密算法，第一轮共有15种算法入选，其中5种算法入围了决赛，分别是MARS，RC6，Rijndael，Serpent和Twofish。又经过3年的验证、评测及公众讨论之后Rijndael算法最终入选。
Rijndael算法之所以最终能够被选为AES的原因是其安全、性能好、效率高、实用灵活。
Rijndael算法支持多种分组及密钥长度，介于128-256之间所有32的倍数均可，最小支持128位，最大256位，而AES标准支持的分组大小固定为128位，密钥长度有3种选择：128位、192位及256位。
二、AES算法的数学基础 Rijndaels算法中的许多运算是按字节和4字节的字来定义的。把一个字节看成是在有限域GF(2^8)上的一个元素。有限域（Finite Field）又名伽罗瓦域（Galois field），简单言之就是一个满足特定规则的集合，集合中的元素可以进行加减乘除运算，且运算结果也是属于此集合。
1. AES的基础域是有限域 GF(28)  一个字节的全体256种取值构成一个GF(28) 一个GF(2)上的8次既约多项式可生成一个 GF(28)
 GF(28)的全体元素构成加法交换群、线性空间。 GF(28)的非零元素构成乘法循环群。  2. AES的GF(28)表示 有限域GF(2^8)上的元素有多种表示方法，为了方便，Rijndaels算法采用多项式表示法，下面是与还表示方法相关的几个定义
定义1 : 一个由比特位b7b6b5b4b3b2b1b0 组成的字节可表示成系数为(0, 1)的二进制多项式：b7X7 + b6X6 + b5X5 + b4X4 + b3X3 + b2X2 + b1X + b0
例：字节57＝01010111的多项式表示为: $$x^6 + x^4 + x^2 + x + 1$$
定义2 : 在GF(28)上的加法定义为二进制多项式的加法，其系数按位模2加。
例： 57＋83＝D4等价于 $$(x^6+x^4+x^2+x+1)⊕(x^7+x+1)= x^7+x^6+x^4+x^2$$
定义3 : 在GF(28)上的乘法定义为二进制多项式的乘积模一个次数为8的不可约多项式 $$m(x) = x^8+x^4+x^3+x+1$$
其系数的十六进制表示为11B
例： 57×83＝C1等价于
$$(x^6+x^4+x^2+x+1)×(x^7+x+1) \ mod \ m (x) = x^{13 }+ x^{11}+x^9+x^8+x^6+x^5+x^4+x^3+1 \ mod \ x^8+x^4+x^3+x+1 = x^7+x^6+1 $$</description>
    </item>
    
    <item>
      <title>DES加密算法原理及实现</title>
      <link>https://jordonyang.github.io/post/impl-of-des/</link>
      <pubDate>Tue, 09 Oct 2018 22:06:42 +0800</pubDate>
      
      <guid>https://jordonyang.github.io/post/impl-of-des/</guid>
      <description>一. DES概述 数据加密标准（Data Encryption Standard），一种使用密钥加密的块算法，1977年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），并授权在非密级政府通信中使用，随后该算法在国际上广泛流传开来。需要注意的是，在某些文献中，作为算法的DES称为数据加密算法（Data Encryption Algorithm,DEA），已与作为标准的DES区分开来。
1. 几个重要的历史时间  1973年美国国家标准局（NBS）向社会公开征集加 密算法，以制定加密算法标准； 1974年第二次征集； 1975年选中IBM的算法，并公布征求意见； 1977年1月15日正式颁布； 1998年底以后停用； 1999年颁布3DES为新标准。  2. 标准加密算法的目标  用于加密保护政府机构和商业部门的非机密的敏感 数据。 用于加密保护静态存储和传输信道中的数据。 安全使用10 ~ 15年。
  3.密码的整体特点  分组密码，明文、密文和密钥的分组长度都是64位。 面向二进制的密码算法，因而能够加解密任何形式的计算机数据。 对合运算:
 f = f–1 加密和解密共用同一算法，使工程实现的工作量减半。
  综合运用了置换、代替、代数等基本密码技术。 基本结构属于Feistel结构。
  4. 应用  在全世界范围得到广泛应用。 许多国际组织采用为标准。 产品形式：软件（嵌入式，应用软件） 硬件（芯片，插卡）  5. 结论  用于其设计目标是安全的。 设计精巧、实现容易、使用方便，堪称典范。 为国际信息安全发挥了重要作用。
  二. 加密过程  64位密钥经子密钥产生算法产生出16个子密钥： K1, K2, &amp;hellip;, K16 ， 分别供第一次, 第二次, &amp;hellip;, 第十六次加密迭代使用。 64位明文经初始置换IP， 将数据打乱重排并分成左右两半。左边32位构成L0 ， 右边2位构成R0 。 第一次加密迭代：由加密函数f实现子密钥k1对R0的加密，得到32位的f(R0, K1)，然后L0⊕f(R0, K1)，32位的结果作为第二次加密迭代的R1，以R0作为第二次加密迭代的L1。</description>
    </item>
    
    <item>
      <title>ExpressionGenerator - 基于二叉树数据结构的算术表达式生成器</title>
      <link>https://jordonyang.github.io/post/arithmetic-expression-generator-based-on-binary-tree-structure/</link>
      <pubDate>Tue, 18 Sep 2018 20:25:43 +0800</pubDate>
      
      <guid>https://jordonyang.github.io/post/arithmetic-expression-generator-based-on-binary-tree-structure/</guid>
      <description>Github仓库
前言 : 学校软件工程课程作业， 需求大概是根据参数随机产生n道算术表达式，将表达式及结果写到文件中，将用户提交的答案文件与正确答案进行比对，输出比对结果。
一. PSP2.1表格    PSP2.1 Personal Software Process Stages 预估耗时（分钟） 实际耗时（分钟）     Planning 计划 20 25   · Estimate · 估计这个任务需要多少时间 20 25   Development 开发 1280 1740   · Analysis · 需求分析 (包括学习新技术) 40 55   · Design Spec · 生成设计文档 40 41   · Design Review · 设计复审 (和同事审核设计文档) 30 20   · Coding Standard · 代码规范 (为目前的开发制定合适的规范) 30 31   · Design · 具体设计 40 66   · Coding · 具体编码 1000 1422   · Code Review · 代码复审 40 41   · Test · 测试（自我测试，修改代码，提交修改） 60 64   Reporting 报告 70 103   · Test Report · 测试报告 20 24   · Size Measurement · 计算工作量 20 21   · Postmortem &amp;amp; Process Improvement Plan · 事后总结, 并提出过程改进计划 30 58   合计  1370 1868    二.</description>
    </item>
    
    <item>
      <title>WordCounter - 基于责任链设计模式的代码文件分析统计器</title>
      <link>https://jordonyang.github.io/post/code-file-analyser-and-counter-based-on-chain-of-responsibility-disgn-pattern/</link>
      <pubDate>Fri, 14 Sep 2018 12:23:56 +0800</pubDate>
      
      <guid>https://jordonyang.github.io/post/code-file-analyser-and-counter-based-on-chain-of-responsibility-disgn-pattern/</guid>
      <description>Github仓库地址
前言 ： 该项目是学校软件工程课程的一个小作业，要求大概是分析统计代码文件中的一些数据（如行数、词数、注释行数、代码行数、字符数等），下面简单介绍下我的完成情况。
一. PSP2.1表格    PSP2.1 Personal Software Process Stages 预估耗时（分钟） 实际耗时（分钟）     Planning 计划 20 35   · Estimate · 估计这个任务需要多少时间 20 35   Development 开发 460 842   · Analysis · 需求分析 (包括学习新技术) 100 221   · Design Spec · 生成设计文档 30 41   · Design Review · 设计复审 (和同事审核设计文档) 20 38   · Coding Standard · 代码规范 (为目前的开发制定合适的规范) 30 39   · Design · 具体设计 30 54   · Coding · 具体编码 200 367   · Code Review · 代码复审 20 38   · Test · 测试（自我测试，修改代码，提交修改） 30 44   Reporting 报告 130 43   · Test Report · 测试报告 60 128   · Size Measurement · 计算工作量 40 51   · Postmortem &amp;amp; Process Improvement Plan · 事后总结, 并提出过程改进计划 30 46   合计  610 920    二.</description>
    </item>
    
    <item>
      <title>Digging in Source Code of HashMap (JDK1.7)</title>
      <link>https://jordonyang.github.io/post/digging-in-sourse-of-hashmap-jdk1.7/</link>
      <pubDate>Mon, 27 Aug 2018 12:01:48 +0800</pubDate>
      
      <guid>https://jordonyang.github.io/post/digging-in-sourse-of-hashmap-jdk1.7/</guid>
      <description>概述  横向维护一个Entry数组，用来存放最近一次添加的(key,value)形式的元素 每个数组元素纵向维护一个Entry链表，当发生哈希冲突时，将原先的Entry往后挪，即链地址法解决哈希冲突  方法签名 public class HashMap&amp;lt;K,V&amp;gt; extends AbstractMap&amp;lt;K,V&amp;gt; implements Map&amp;lt;K,V&amp;gt;, Cloneable, Serializable  具有Map的基本方法，可克隆、可序列化（自定义的序列化规则）
基本属性 // 默认容量为16 static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4; // 最大容量 static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30; // 默认加载因子，值为0.75，扩容时用 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 空的入口数组 static final Entry&amp;lt;?,?&amp;gt;[] EMPTY_TABLE = {}; /** * 入口数组，用来存储链表的头结点 * 一开始将它指向 EMPTY_TABLE，这样的意图直到在第一次添加元素时 * 才正式将table指向大小接近threshold的Entry对象 */ transient Entry&amp;lt;K,V&amp;gt;[] table = (Entry&amp;lt;K,V&amp;gt;[]) EMPTY_TABLE; // 当前表中的元素个数 transient int size; /** * 阈值，超过后扩容，值为capacity * load factor * 一开始table为 EMPTY_TABLE，即创建HashMap对象但未往其中添加元素， * 当第一次往其中添加元素时，表的大小会膨胀到这个值 */ int threshold; // 加载因子 final float loadFactor; // 结构性修改的次数，与fail-fast机制有关 transient int modCount;  构造方法 1.</description>
    </item>
    
    <item>
      <title>JVM垃圾收集机制</title>
      <link>https://jordonyang.github.io/post/garbage-collection-of-jvm/</link>
      <pubDate>Sat, 04 Aug 2018 23:25:14 +0800</pubDate>
      
      <guid>https://jordonyang.github.io/post/garbage-collection-of-jvm/</guid>
      <description>一. 概念 什么是垃圾收集?
垃圾收集（Garbage Collection，GC），指的是对Java堆和方法区的死对象进行回收。它诞生于1960年 MIT 的 Lisp 语言，经过半个多世纪，现已十分成熟。
二. 收集的范围 哪些内存需要回收
在Java内存运行时区域中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，加上基本认为栈帧所分配的大小随类的结构确定而保持不变，因此这些区域的的内存分配和回收都具有确定性，所以我们的内存垃圾回收主要集中于 Java 堆和方法区中，在程序运行期间，这部分内存的分配和回收都是动态的 。
三. 收集目标  Java堆：回收目标为死对象，即那些不会不可能再被任何途径使用的对象。 方法区，即Hotspot VM中的永久代（Permanet Generation）：收集效率非常低，其中进行内存垃圾回收的两个主要内容是废弃常量和无用的类。  四. 判活算法 怎么判断一个对象是否死对象？
1. 引用计数（Reference Counting） 即每个对象都有一个引用计数器，当有引用连接至对象时，引用计数加1；当有引用离开作用域或被置为null时，引用计数减1。此方法简单、高效，但无法解决对象相互循环引用的问题。
 若对象间存在循环引用，可能出现“对象应该被回收，但引用计数却不为零”的情况。定位这样的交互自引用的对象组所需的工作量极大。引用记数常用来说明垃圾收集的工作方式，但似乎从未被应用于任何一种Java虚拟机实现中。
 2. 可达性分析（Reachability Analysis） 从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。
GC停顿：亦称Stop The World（STW），即在整个可达性分析期间，整个执行系统看起来就像是被冻结在某个时间点上，不能出现在分析过程中对象引用关系还在不断变化的情况。
在Java语言中，GC Roots包括：
 虚拟机栈中引用的对象 方法区中类静态属性实体引用的对象 方法区中常量引用的对象 本地方法栈中JNI引用的对象  五. 收集方法 有哪些垃圾收集算法？它们各有什么特点？
1. 标记 - 清除算法（Mark-Sweep） （ 1 ）原始标记-清除算法 （Naïve mark-and-sweep） 每个对象在内存中都有一个标记位用于垃圾回收，标记该对象到 GC roots 是否可达，然后进行 标记-清理 过程</description>
    </item>
    
    <item>
      <title>LinkedList源码阅读与分析</title>
      <link>https://jordonyang.github.io/post/digging-in-source-code-of-linkedlist/</link>
      <pubDate>Mon, 25 Jun 2018 16:44:03 +0800</pubDate>
      
      <guid>https://jordonyang.github.io/post/digging-in-source-code-of-linkedlist/</guid>
      <description>一. 概述  LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。 LinkedList 实现 List 接口，能对它进行队列操作。 LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。 LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。 LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。 LinkedList 是非同步的。
 二. 基本属性 其中 size 为 LinkedList 的大小，first 和 last 分别为链表的头结点和尾结点。Node 为结点对象。
// 表中已有元素个数 transient int size = 0; // 头结点指针 transient Node&amp;lt;E&amp;gt; first; // 尾结点指针 transient Node&amp;lt;E&amp;gt; last;  Node是LinkedList的一个静态内部类，采用典型的双链表结构，定义了存储的数据元素，前一个结点和后一个结点
private static class Node&amp;lt;E&amp;gt; { // 结点数据 E item; // 前一个结点 Node&amp;lt;E&amp;gt; next; // 后一个结点 Node&amp;lt;E&amp;gt; prev; Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) { this.</description>
    </item>
    
    <item>
      <title>ArrayList源码阅读与分析</title>
      <link>https://jordonyang.github.io/post/digging-in-source-code-of-arraylist/</link>
      <pubDate>Sat, 23 Jun 2018 22:40:02 +0800</pubDate>
      
      <guid>https://jordonyang.github.io/post/digging-in-source-code-of-arraylist/</guid>
      <description>一. 继承体系  1.基于数组实现，是一个动态数组，其容量能自动增长。
2.ArrayList不是线程安全的，建议在单线程中使用，多线程可以选择Vector或CopyOnWriteArrayList。
3.实现了RandomAccess接口，可以通过下标序号进行快速访问。
4.实现了Cloneable接口，能被克隆。
5.实现了Serializable接口，支持序列化。
 二. 基本属性 /** * 存储数组默认容量 */ private static final int DEFAULT_CAPACITY = 10; /** * 当使用 new ArrayList(0) 时赋值给elementData * 第一次插入元素时，将重新开辟一个容量为1的存储数组，该引用将被弃用 */ private static final Object[] EMPTY_ELEMENTDATA = {}; /** * 当使用 new ArrayList() 时赋值给elementData * 第一次插入元素时，将重新开辟一个容量为10的存储数组，该引用将被弃用 */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; /** * 该数组用来存放add进ArrayList的元素 */ transient Object[] elementData; /** * 对象数组中已经存放的元素个数，并不是存储数组的容量 */ private int size; /** * 数组可开辟的最大容量，实际上一个数组所能分配的容量大小取决于JVM分配的堆内存大小 * MAX_ARRAY_SIZE只是一个理论值，可能出于对JVM头信息存储的考虑而设计 * 因为在hugeCapacity 方法中 minCapacity &amp;gt; MAX_ARRAY_SIZE) ?</description>
    </item>
    
    <item>
      <title>Thread类的run()方法执行过程跟踪和思考</title>
      <link>https://jordonyang.github.io/post/thread-run-method-execution-process-tracking-and-thinking/</link>
      <pubDate>Sun, 25 Mar 2018 21:46:51 +0800</pubDate>
      
      <guid>https://jordonyang.github.io/post/thread-run-method-execution-process-tracking-and-thinking/</guid>
      <description>前言 之前听到很多说法都是:“单纯地执行Thread子类的run方法并没有多线程的效果，正确的做法是，用Thread子类对象执行Thread的start方法，这样start方法会自动执行子类的run方法。” 我对这种神奇的说法将信将疑，心里总感觉不踏实，于是点进Thread的源码了解了一下。
一. 入坑过程 然而，纵观 start 方法，并没有找到 run 这个词，那run方法又是在哪里被调用的呢？其中最有嫌疑的地方就是native方法start0。
Thread 类有个 registerNatives 本地方法，该方法主要的作用就是注册一些本地方法供 Thread 类使用，如 start0()，stop0() 等等，可以说，所有操作本地线程的本地方法都是由它注册的。这个方法放在一个静态代码块中，当 Thread 类被加载到 JVM 中的时候，它就会被调用，进而注册相应的本地方法。 而本地方法 registerNatives 是定义在 openjdk\jdk\src\share\native\java\lang\Thread.c文件 中的。Thread.c 是个很小的文件，它定义了各个操作系统平台都要用到的关于线程的公用数据和操作，如下：
可以容易的看出 Java 线程调用start-&amp;gt;start0的方法，实际上会调用到 JVM_StartThread 方法，而 JVM_StartThread 方法则是在openjdk\hotspot\src\share\vm\prims\jvm.cpp中定义的
JVM_ENTRY 作为一个宏，用来定义 JVM_StartThread 函数，可以看到函数内创建了真正的平台相关的本地线程，其线程函数是 thread_entry，如下：
可见其中调用了 vmSymbols::run_method_name 方法， 而 run_method_name 是在 openjdk\hotspot\src\share\vm\classfile\vmSymbols.hpp 中用宏定义的：
这样不难想象到执行 Thread.start() 后的底层调用过程
二. 拓展 理解到 statrt0 方法为我们做了哪些事情后就很容易理解Java中线程启动的大致过程。
1. Thread子类 任务类继承Thread类，并覆盖它的run方法
当 subThread 调用父类的start方法时，由上面的过程可以知道，在JVM申请CPU线程资源并开启线程后，会执行 Thread类 的 run 方法,而由于JVM多态支持，最终调用的是 SubThread 的 run 方法，从而实现在一个线程中完成任务。</description>
    </item>
    
    <item>
      <title>通过反编译理解Java foreach 语法糖</title>
      <link>https://jordonyang.github.io/post/understanding-the-foreach-syntax-sugar-by-decompilation/</link>
      <pubDate>Sun, 25 Feb 2018 22:03:56 +0800</pubDate>
      
      <guid>https://jordonyang.github.io/post/understanding-the-foreach-syntax-sugar-by-decompilation/</guid>
      <description>前言 最近一直在看TiJ，在持有对象那章，Bruce Eckel说到Collection的内容可以用foreach遍历，原因是Java SE%引入了Iterable接口，该接口包含一个能够产生Iterator的iterator方法，并且Iterable接口被foreach用来在序列中移动。因此任何Iterable的实现类都可以用于foreach语句。那么我们在尝着这一语法糖的甜头时，JDK底层帮我们做了哪些事情呢？
实验 环境：IntelliJ IDEA 2018.1、jdk1.7.0_80
下面例子的Java代码中使用了两个foreach分别遍历数组和ArrayList：
package reversecompile; import java.util.ArrayList; import java.util.List; public class TestForEach { public static void main(String[] args) { String[] arr = &amp;quot;I am a coder&amp;quot;.split(&amp;quot; &amp;quot;); List&amp;lt;String&amp;gt; strings = new ArrayList&amp;lt;&amp;gt;(); for (String s : arr){ strings.add(s); System.out.println(s); } for (String s : strings){ System.out.println(s); } } }  通过IDEA反编译后的·TestForEach.class：
// // Source code recreated from a .class file by IntelliJ IDEA // (powered by Fernflower decompiler) // package reversecompile; import java.</description>
    </item>
    
    <item>
      <title>2017年阅读记录</title>
      <link>https://jordonyang.github.io/post/my-reading-records-of-2017/</link>
      <pubDate>Wed, 27 Dec 2017 12:21:05 +0800</pubDate>
      
      <guid>https://jordonyang.github.io/post/my-reading-records-of-2017/</guid>
      <description>&lt;h3 id=&#34;已读&#34;&gt;已读&lt;/h3&gt;

&lt;h4 id=&#34;七月&#34;&gt;七月&lt;/h4&gt;

&lt;p&gt;​                                                      &lt;img src=&#34;https://img3.doubanio.com/lpic/s28063701.jpg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;很感人的书，情节紧凑到我一天看完，感触最深最虐心的莫过于看到迪伦和崔斯坦在结界处分别的场景，边看边担忧着主人公的命运，幸好最后还是等到了那句“原来你在这里”。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;九月&#34;&gt;九月&lt;/h4&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img3.doubanio.com/lpic/s27177415.jpg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;叛逆、睥睨一切甚至厌恶一切但又保持着追求对世间美好事物的热情，这何尝不是年少的你我？读完这本混乱得曾让我想扔掉不读的书，我想到的是，或许我们无法选择与谁相遇，但我们可以选择让那些人留在自己的世界里，或许我们改变环境让它变得如愿美好，但至少我们可以改变自己，去追求自己想要的生活。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;h4 id=&#34;十一月&#34;&gt;十一月&lt;/h4&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img3.doubanio.com/lpic/s1081291.jpg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;”鹅“、“梦想储蓄罐”、“梦想相册”、“成功日记”、&amp;rdquo;收入的50%用来让鹅长大，40%放进梦想储蓄罐，10%用作日常开销“、一个个自己以往闻所未闻的概念在书中出现，正是在这样一个科学的理财体系下，当钱钱、金先生等人说出一些赚钱或者一些对问题的解决方案时，你会下意识地相信其可行，自己也会深受鼓舞想要去实践一番。同时你会发现作者在鼓励读者相信和突破自己去管理自己地金钱，规划自己地未来，过上一种对物质从容不迫地生活。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>二叉堆的Java实现</title>
      <link>https://jordonyang.github.io/post/constructing-binary-heap-with-java/</link>
      <pubDate>Mon, 25 Sep 2017 22:32:08 +0800</pubDate>
      
      <guid>https://jordonyang.github.io/post/constructing-binary-heap-with-java/</guid>
      <description>前言 最近在看《算法导论》，从中感受到了算法世界的神奇，看完二叉堆后觉得实现起来应该不难，所以试着根据书中的伪代码用Java实现一遍。
概念 基本定义 二叉堆是一个数组，可近似看成完全二叉树，表示堆的数组A通常包含两个属性：A.length（数组长度）和A.heap-size（堆的有效元素）
private int[] heap; private int heapSize; public MyHeap(int[] array) { this.heap = array; this.heapSize = array.length; }  通过下标定位亲属节点 由于堆可看做完全二叉树，所以可以通过某节点的下标获取其左右子节点和父节点
private int left(int i) { return 2 * i + 1; } private int right(int i) { return 2 * i + 2; } private int parent(int i) { return (i - 1) / 2; }  堆的一些性质  最大堆性质：A[PARENT[i] &amp;gt;= A[i]] 最小堆性质：A[PARENT[i] &amp;lt;= A[i]] 含有n个元素的堆的高为：小于等于lgn的最大整数 当用数组表示存储了n个元素的堆时，叶节点下标分别为 (n/2) + 1, (n / 2) + 2, &amp;hellip;, n（下标从１开始）  维持堆的性质 使下标为i的节点所构成的堆成为最大堆</description>
    </item>
    
  </channel>
</rss>