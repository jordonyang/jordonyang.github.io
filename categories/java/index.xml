<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on 临风博客</title>
    <link>https://jordonyang.github.io/categories/java/</link>
    <description>Recent content in Java on 临风博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh_CN</language>
    <copyright>All rights reserved</copyright>
    <lastBuildDate>Sat, 10 Nov 2018 14:23:26 +0800</lastBuildDate>
    
	<atom:link href="https://jordonyang.github.io/categories/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Understanding And Implementing RSA Algorithm</title>
      <link>https://jordonyang.github.io/post/security/crypto/unsymmetry/rsa/</link>
      <pubDate>Sat, 10 Nov 2018 14:23:26 +0800</pubDate>
      
      <guid>https://jordonyang.github.io/post/security/crypto/unsymmetry/rsa/</guid>
      <description>0x00. TOC  0x01.简介 0x02.应用 0x03.原理 0x04.实现  1.素数的选择与判断 2.实现模逆算法  2.1.欧几里得算法 2.2.扩展欧几里得算法 2.3.求解同余方程算法  3.实现快速模指运算 4.编程实现RSA算法 5.利用RSA进行数据加解密  6.实现对大数据进行加密  7.实现简单的GUI界面 8.分析总结  0x05.攻击方法 0x06.密钥分发 0x07.参考  0x01. 简介 最初的公钥方案是在1977年由Ron Rivest、Adi Shamir和Len Adleman在MIT提出的，并且于1978年首次发表[RIVE78]。 RSA方案从那时起便占据了绝对的统治地位，成为最广泛接受和实现的通用公钥加密方法。 RSA是分组密码，对于某个m它的明文和密文是0〜n - 1之间的整数。TOC
0x02. 应用 用于在开放的网络环境（如Internet）上保护电子通信，而不依赖于隐藏或隐蔽的通道，甚至用于密钥交换。开放的网络环境容易受到各种通信安全问题的影响，比如中间人攻击和欺骗。通信安全通常包括要求通信不得在运输途中可读（保存保密），通信在运输途中不能修改（保证沟通完整性），沟通必须来自一个确定原（发送方真实性），和收件人必须不能否定或拒绝接收的通信。将非对称加密与Enveloped Public Key Encryption（EPKE）方法相结合，允许在开放的网络环境中安全发送通信。换句话说，即使密码分析者听了包括密钥交换在内的整个对话也无法解释对话。
公钥密码术中使用的区别技术是使用非对称密钥算法，其中一方用于执行加密的密钥与另一方用于解密的密钥不同。每个用户都有一对加密密钥——一个公共加密密钥和一个私有解密密钥。例如，用于数字签名的密钥对（包括一个私有签名密钥和一个公共验证密钥）。公钥可以广泛分发，而私钥只有其所有者知道。它们在数学上是相关的，但是选择参数是为了从公钥计算私钥是不可行的。
相反，对称密钥算法使用的是一个秘密密钥，它必须由发送方（用于加密)和接收方）用于解密)共享并保持私有。要使用对称加密方案，发送方和接收方必须事先安全地共享密钥。
由于对称密钥算法几乎总是比非对称密钥算法计算量小得多，所以通常使用密钥交换算法交换密钥，然后使用该密钥和对称密钥算法传输数据。PGP和SSL/TLS方案家族使用这个过程，因此称为混合加密系统。综上非对称算法适用于 TOC
 密钥交换 数字签名 与对称加密算法混合使用（PGP, SSL, TLS）  0x03. 原理 对于某一明文块M和密文块C，加密和解密有如下的形式： $$C = M^e \ mod \ n$$ $$M = C^d \ mod \ n = (M^e)^d \ mod\ n = M^{ed} mod \ n$$</description>
    </item>
    
    <item>
      <title>Understanding Stream Cipher and Implementation of RC4</title>
      <link>https://jordonyang.github.io/post/security/crypto/symmetry/rc4/</link>
      <pubDate>Sat, 10 Nov 2018 10:01:04 +0800</pubDate>
      
      <guid>https://jordonyang.github.io/post/security/crypto/symmetry/rc4/</guid>
      <description>前言 分组密码每次处理一个输入分组，并为每个输入分组产生一个输出分组。流密码连续处理输入元素，在运行过程中，一次产生一个输出元素。尽管分组密码普遍得多，但对于一些特定的应用，使用流密码更合适。
一. 流密码结构 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;典型的流密码一次加密一个字节的明文，尽管流密码可能设计成一次操作一个比特或者比字节大的单位。图2.7是流密码结构的示意图。在这个结构里，密钥输入到一个伪随机字节生成器，产生一个表面随机的8比特数据流。如果不知道输入密钥，伪随机流就不可预测的，而且它具有表面上随机的性质。这个生成器的输出称为密钥流，使用位异或操作与明文流结合，一次一个字节。例如，如果生成器产生的下一字节是01101100，明文的下一字节是11001100，那么得到的密文字节是： $$11001100 ⊕ 01101100 \ = \ 10100000$$ 解密需要同一伪随机序列： $$10100000 ⊕ 01101100 \ = \ 11001100 $$
[KUMA97]列出了下列设计流密码时需要重要考虑的因素：
 加密序列应该有一个长周期。伪随机数生成器使用一个函数产生一个实际上不断重复的确定比特流。这个重复的周期越长，密码破解就越困难。 密钥流应该尽可能地接近真随机数流的性质。例如， 1和0的数目应该近似相等。如果将密钥流视作字节流，那么字节的256种可能值出现的频率应该近似相等。密钥流表现得越随机，密文就越随机化，密码破译就越困难。 图2.6指出了伪随机数生成器的输出受输入密钥值控制。为了抵抗穷举攻击，这个密钥必须非常长。分组密码中的考虑因素在这里同样适用。因此，就当前的科技水平而言，需要至少128比特长度的密钥。  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果伪随机数生成器设计合理，对同样的密钥长度，流密码和分组密码一样安全。流密码的主要优点是流密码与分组密码相比几乎总是更快，使用更少的代码。本文中的示例RC4能用仅仅几行代码实现。最近几年，随着AES的引进，这个优势己经消失了，因为AES可以用软件方式高效实现。比如，Intel AES指令集含有一轮加解密和密钥产生过程使用的机器指令。使用硬件指令实现AES跟仅使用软件方式相比，速度提高了一个数M级。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;分组密码的优点是可以重复使用密钥。但是如果两个明文使用同一密钥进行流密码加密，密码破译常常会非常容易[DAWS96]。如果将这两个密文流进行异或，结果就是原始明文的异或值。如果明文是文本字符串、信用卡号或者其他己知其性质的字节流，密码破解可能会成功。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对于需要加密/解密数据流的应用，比如在数据通信信道或者浏览器/网络链路上，流密码也许是更好的选择。对于处理数据分组的应用，比如文件传递、电子邮件和数据库，分组密码可能更合适。但是，这两种密码都可以在几乎所有的应用中使用。
二. RC4算法 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RC4是Ron Rivest在1987年为RSA Security公司设计的流密码。它是密钥大小可变的流密码，使用面向字节的操作。这个算法基于随机交换的使用。通过分析指出，这个密码的周期完全可能大于10100[ROBS95a]。每输出一个字节需要8~16个机器操作，并且此密码用软件实现运行速度非常快。为网络浏览器和服务器之间的通信定义的SS17TLS (安全套接字层/传输层安全）标准中使用了RC4。它也被用于属于IEEE 802.11无线LAN标准一部分的WEP (有线等效保密）协议及更新的Wi-Fi保护访问（WPA) 协议 。 RC4原本被RSA Security公司当作商业秘密。1994年9月，RC4算法通过Cypherpunks匿名邮件转发列表匿名地公布在因特网上。
1. 算法细节 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RC4算法非常简单，易于描述。用一个可变长度为1〜256字节(8-2048比特）的密钥来初始化256字节的状态向S，其元素为S[0], S[l] , …, S[255]。从始至终置换后的S包含从0到255的所有8位数。加密和解密时，字节k（见上图）是从S的255个元素中按一种系统的方式选出的。每次k值产生之后，要重新排列S的元素。
2. 初始化S &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;开始时， S的元素按升序被置为0〜255；即S[0] = 0, S[l] = l, S[255] = 255。同时创建一个临时向量T。如果密钥K的长度为256字节，就把K直接赋给T，否则，对于keylen字节长度的密钥，将K赋值给T的前keylen个元素，并循环重复用K的值赋给T剩下的元素，直到T的所有元素都被赋值。这些预操作可被概括为
/* 初始化 */ for i = 0 to 255 do S[i] = i； T[i] = K[i mod keylen];  然后用T产生S的初始置换，从S[0]〜S[255]，对每个S[i],根据由T[i]确定的方案，并将S[i]置换为S的另一字节：</description>
    </item>
    
    <item>
      <title>Implementation of AES Algorithm</title>
      <link>https://jordonyang.github.io/post/impl-of-aes/</link>
      <pubDate>Thu, 18 Oct 2018 22:23:44 +0800</pubDate>
      
      <guid>https://jordonyang.github.io/post/impl-of-aes/</guid>
      <description>0x00. TOC  0x01.概述 0x02.AES算法的数学基础  1.有限域 2. AES在有限域上的表示 2. AES的字表示与运算 2.1. 字表示 2.2. 字运算  0x03.AES的加密过程  1.状态 2.加密过程概述 3.AES有限域上加加法 4.轮密钥的生成  4.1.密钥扩展 4.2.轮密钥的选择 4.3.代码实现  5.AES基本变换  5.1.S盒变换 5.2.行移位变换 5.3.列混合变换  6.对外加密接口 7.核心加密逻辑   0x04.解密过程  1.AES基本逆变换 2.对外解密接口 3.核心解密逻辑  0x05.测试 0x06.说明 0x07.参考  0x01. 概述 美国政府在1997年9月12日公开征集更高效更安全的替代DES加密算法，第一轮共有15种算法入选，其中5种算法入围了决赛，分别是MARS，RC6，Rijndael，Serpent和Twofish。又经过3年的验证、评测及公众讨论之后Rijndael算法最终入选。
Rijndael算法之所以最终能够被选为AES的原因是其安全、性能好、效率高、实用灵活。
Rijndael算法支持多种分组及密钥长度，介于128-256之间所有32的倍数均可，最小支持128位，最大256位，而AES标准支持的分组大小固定为128位，密钥长度有3种选择：128位、192位及256位。TOC
0x02. AES算法的数学基础 Rijndaels算法中的许多运算是按字节和4字节的字来定义的。把一个字节看成是在有限域GF(2^8)上的一个元素。有限域（Finite Field）又名伽罗瓦域（Galois field），简单言之就是一个满足特定规则的集合，集合中的元素可以进行加减乘除运算，且运算结果也是属于此集合。 TOC
1. 有限域 AES的基础域是有限域 GF(28) TOC
 一个字节的全体256种取值构成一个GF(28) 一个GF(2)上的8次既约多项式可生成一个 GF(28)
 GF(28)的全体元素构成加法交换群、线性空间。 GF(28)的非零元素构成乘法循环群。  2.</description>
    </item>
    
    <item>
      <title>Implementation of DES Algorithm</title>
      <link>https://jordonyang.github.io/post/impl-of-des/</link>
      <pubDate>Tue, 09 Oct 2018 22:06:42 +0800</pubDate>
      
      <guid>https://jordonyang.github.io/post/impl-of-des/</guid>
      <description>一. DES概述 数据加密标准（Data Encryption Standard），一种使用密钥加密的块算法，1977年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），并授权在非密级政府通信中使用，随后该算法在国际上广泛流传开来。需要注意的是，在某些文献中，作为算法的DES称为数据加密算法（Data Encryption Algorithm,DEA），已与作为标准的DES区分开来。
1. 几个重要的历史时间  1973年美国国家标准局（NBS）向社会公开征集加 密算法，以制定加密算法标准； 1974年第二次征集； 1975年选中IBM的算法，并公布征求意见； 1977年1月15日正式颁布； 1998年底以后停用； 1999年颁布3DES为新标准。  2. 标准加密算法的目标  用于加密保护政府机构和商业部门的非机密的敏感 数据。 用于加密保护静态存储和传输信道中的数据。 安全使用10 ~ 15年。
  3.密码的整体特点  分组密码，明文、密文和密钥的分组长度都是64位。 面向二进制的密码算法，因而能够加解密任何形式的计算机数据。 对合运算:
 f = f–1 加密和解密共用同一算法，使工程实现的工作量减半。
  综合运用了置换、代替、代数等基本密码技术。 基本结构属于Feistel结构。
  4. 应用  在全世界范围得到广泛应用。 许多国际组织采用为标准。 产品形式：软件（嵌入式，应用软件） 硬件（芯片，插卡）  5. 结论  用于其设计目标是安全的。 设计精巧、实现容易、使用方便，堪称典范。 为国际信息安全发挥了重要作用。
  二. 加密过程  64位密钥经子密钥产生算法产生出16个子密钥： K1, K2, &amp;hellip;, K16 ， 分别供第一次, 第二次, &amp;hellip;, 第十六次加密迭代使用。 64位明文经初始置换IP， 将数据打乱重排并分成左右两半。左边32位构成L0 ， 右边2位构成R0 。 第一次加密迭代：由加密函数f实现子密钥k1对R0的加密，得到32位的f(R0, K1)，然后L0⊕f(R0, K1)，32位的结果作为第二次加密迭代的R1，以R0作为第二次加密迭代的L1。</description>
    </item>
    
    <item>
      <title>An Arithmetic Expression Generator Based on Binary Tree Structure</title>
      <link>https://jordonyang.github.io/post/arithmetic-expression-generator-based-on-binary-tree-structure/</link>
      <pubDate>Tue, 18 Sep 2018 20:25:43 +0800</pubDate>
      
      <guid>https://jordonyang.github.io/post/arithmetic-expression-generator-based-on-binary-tree-structure/</guid>
      <description>Github仓库
前言 : 学校软件工程课程作业， 需求大概是根据参数随机产生n道算术表达式，将表达式及结果写到文件中，将用户提交的答案文件与正确答案进行比对，输出比对结果。
一. PSP2.1表格    PSP2.1 Personal Software Process Stages 预估耗时（分钟） 实际耗时（分钟）     Planning 计划 20 25   · Estimate · 估计这个任务需要多少时间 20 25   Development 开发 1280 1740   · Analysis · 需求分析 (包括学习新技术) 40 55   · Design Spec · 生成设计文档 40 41   · Design Review · 设计复审 (和同事审核设计文档) 30 20   · Coding Standard · 代码规范 (为目前的开发制定合适的规范) 30 31   · Design · 具体设计 40 66   · Coding · 具体编码 1000 1422   · Code Review · 代码复审 40 41   · Test · 测试（自我测试，修改代码，提交修改） 60 64   Reporting 报告 70 103   · Test Report · 测试报告 20 24   · Size Measurement · 计算工作量 20 21   · Postmortem &amp;amp; Process Improvement Plan · 事后总结, 并提出过程改进计划 30 58   合计  1370 1868    二.</description>
    </item>
    
    <item>
      <title>Code File Analyser and Counter Based on Chain of Responsibility Disgn Pattern</title>
      <link>https://jordonyang.github.io/post/code-file-analyser-and-counter-based-on-chain-of-responsibility-disgn-pattern/</link>
      <pubDate>Fri, 14 Sep 2018 12:23:56 +0800</pubDate>
      
      <guid>https://jordonyang.github.io/post/code-file-analyser-and-counter-based-on-chain-of-responsibility-disgn-pattern/</guid>
      <description>Github仓库地址
前言 ： 该项目是学校软件工程课程的一个小作业，要求大概是分析统计代码文件中的一些数据（如行数、词数、注释行数、代码行数、字符数等），下面简单介绍下我的完成情况。
一. PSP2.1表格    PSP2.1 Personal Software Process Stages 预估耗时（分钟） 实际耗时（分钟）     Planning 计划 20 35   · Estimate · 估计这个任务需要多少时间 20 35   Development 开发 460 842   · Analysis · 需求分析 (包括学习新技术) 100 221   · Design Spec · 生成设计文档 30 41   · Design Review · 设计复审 (和同事审核设计文档) 20 38   · Coding Standard · 代码规范 (为目前的开发制定合适的规范) 30 39   · Design · 具体设计 30 54   · Coding · 具体编码 200 367   · Code Review · 代码复审 20 38   · Test · 测试（自我测试，修改代码，提交修改） 30 44   Reporting 报告 130 43   · Test Report · 测试报告 60 128   · Size Measurement · 计算工作量 40 51   · Postmortem &amp;amp; Process Improvement Plan · 事后总结, 并提出过程改进计划 30 46   合计  610 920    二.</description>
    </item>
    
    <item>
      <title>Digging in Source Code of HashMap (JDK1.7)</title>
      <link>https://jordonyang.github.io/post/digging-in-sourse-of-hashmap-jdk1.7/</link>
      <pubDate>Mon, 27 Aug 2018 12:01:48 +0800</pubDate>
      
      <guid>https://jordonyang.github.io/post/digging-in-sourse-of-hashmap-jdk1.7/</guid>
      <description>概述  横向维护一个Entry数组，用来存放最近一次添加的(key,value)形式的元素 每个数组元素纵向维护一个Entry链表，当发生哈希冲突时，将原先的Entry往后挪，即链地址法解决哈希冲突  方法签名 public class HashMap&amp;lt;K,V&amp;gt; extends AbstractMap&amp;lt;K,V&amp;gt; implements Map&amp;lt;K,V&amp;gt;, Cloneable, Serializable  具有Map的基本方法，可克隆、可序列化（自定义的序列化规则）
基本属性 // 默认容量为16 static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4; // 最大容量 static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30; // 默认加载因子，值为0.75，扩容时用 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 空的入口数组 static final Entry&amp;lt;?,?&amp;gt;[] EMPTY_TABLE = {}; /** * 入口数组，用来存储链表的头结点 * 一开始将它指向 EMPTY_TABLE，这样的意图直到在第一次添加元素时 * 才正式将table指向大小接近threshold的Entry对象 */ transient Entry&amp;lt;K,V&amp;gt;[] table = (Entry&amp;lt;K,V&amp;gt;[]) EMPTY_TABLE; // 当前表中的元素个数 transient int size; /** * 阈值，超过后扩容，值为capacity * load factor * 一开始table为 EMPTY_TABLE，即创建HashMap对象但未往其中添加元素， * 当第一次往其中添加元素时，表的大小会膨胀到这个值 */ int threshold; // 加载因子 final float loadFactor; // 结构性修改的次数，与fail-fast机制有关 transient int modCount;  构造方法 1.</description>
    </item>
    
    <item>
      <title>The Garbage Collection Mechanism of the JVM</title>
      <link>https://jordonyang.github.io/post/garbage-collection-of-jvm/</link>
      <pubDate>Sat, 04 Aug 2018 23:25:14 +0800</pubDate>
      
      <guid>https://jordonyang.github.io/post/garbage-collection-of-jvm/</guid>
      <description>一. 概念 什么是垃圾收集?
垃圾收集（Garbage Collection，GC），指的是对Java堆和方法区的死对象进行回收。它诞生于1960年 MIT 的 Lisp 语言，经过半个多世纪，现已十分成熟。
二. 收集的范围 哪些内存需要回收
在Java内存运行时区域中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，加上基本认为栈帧所分配的大小随类的结构确定而保持不变，因此这些区域的的内存分配和回收都具有确定性，所以我们的内存垃圾回收主要集中于 Java 堆和方法区中，在程序运行期间，这部分内存的分配和回收都是动态的 。
三. 收集目标  Java堆：回收目标为死对象，即那些不会不可能再被任何途径使用的对象。 方法区，即Hotspot VM中的永久代（Permanet Generation）：收集效率非常低，其中进行内存垃圾回收的两个主要内容是废弃常量和无用的类。  四. 判活算法 怎么判断一个对象是否死对象？
1. 引用计数（Reference Counting） 即每个对象都有一个引用计数器，当有引用连接至对象时，引用计数加1；当有引用离开作用域或被置为null时，引用计数减1。此方法简单、高效，但无法解决对象相互循环引用的问题。
 若对象间存在循环引用，可能出现“对象应该被回收，但引用计数却不为零”的情况。定位这样的交互自引用的对象组所需的工作量极大。引用记数常用来说明垃圾收集的工作方式，但似乎从未被应用于任何一种Java虚拟机实现中。
 2. 可达性分析（Reachability Analysis） 从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。
GC停顿：亦称Stop The World（STW），即在整个可达性分析期间，整个执行系统看起来就像是被冻结在某个时间点上，不能出现在分析过程中对象引用关系还在不断变化的情况。
在Java语言中，GC Roots包括：
 虚拟机栈中引用的对象 方法区中类静态属性实体引用的对象 方法区中常量引用的对象 本地方法栈中JNI引用的对象  五. 收集方法 有哪些垃圾收集算法？它们各有什么特点？
1. 标记 - 清除算法（Mark-Sweep） （ 1 ）原始标记-清除算法 （Naïve mark-and-sweep） 每个对象在内存中都有一个标记位用于垃圾回收，标记该对象到 GC roots 是否可达，然后进行 标记-清理 过程</description>
    </item>
    
    <item>
      <title>Digging in Source Code of LinkedList</title>
      <link>https://jordonyang.github.io/post/digging-in-source-code-of-linkedlist/</link>
      <pubDate>Mon, 25 Jun 2018 16:44:03 +0800</pubDate>
      
      <guid>https://jordonyang.github.io/post/digging-in-source-code-of-linkedlist/</guid>
      <description>一. 概述  LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。 LinkedList 实现 List 接口，能对它进行队列操作。 LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。 LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。 LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。 LinkedList 是非同步的。
 二. 基本属性 其中 size 为 LinkedList 的大小，first 和 last 分别为链表的头结点和尾结点。Node 为结点对象。
// 表中已有元素个数 transient int size = 0; // 头结点指针 transient Node&amp;lt;E&amp;gt; first; // 尾结点指针 transient Node&amp;lt;E&amp;gt; last;  Node是LinkedList的一个静态内部类，采用典型的双链表结构，定义了存储的数据元素，前一个结点和后一个结点
private static class Node&amp;lt;E&amp;gt; { // 结点数据 E item; // 前一个结点 Node&amp;lt;E&amp;gt; next; // 后一个结点 Node&amp;lt;E&amp;gt; prev; Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) { this.</description>
    </item>
    
    <item>
      <title>Digging in Source Code of ArrayList</title>
      <link>https://jordonyang.github.io/post/digging-in-source-code-of-arraylist/</link>
      <pubDate>Sat, 23 Jun 2018 22:40:02 +0800</pubDate>
      
      <guid>https://jordonyang.github.io/post/digging-in-source-code-of-arraylist/</guid>
      <description>一. 继承体系  1.基于数组实现，是一个动态数组，其容量能自动增长。
2.ArrayList不是线程安全的，建议在单线程中使用，多线程可以选择Vector或CopyOnWriteArrayList。
3.实现了RandomAccess接口，可以通过下标序号进行快速访问。
4.实现了Cloneable接口，能被克隆。
5.实现了Serializable接口，支持序列化。
 二. 基本属性 /** * 存储数组默认容量 */ private static final int DEFAULT_CAPACITY = 10; /** * 当使用 new ArrayList(0) 时赋值给elementData * 第一次插入元素时，将重新开辟一个容量为1的存储数组，该引用将被弃用 */ private static final Object[] EMPTY_ELEMENTDATA = {}; /** * 当使用 new ArrayList() 时赋值给elementData * 第一次插入元素时，将重新开辟一个容量为10的存储数组，该引用将被弃用 */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; /** * 该数组用来存放add进ArrayList的元素 */ transient Object[] elementData; /** * 对象数组中已经存放的元素个数，并不是存储数组的容量 */ private int size; /** * 数组可开辟的最大容量，实际上一个数组所能分配的容量大小取决于JVM分配的堆内存大小 * MAX_ARRAY_SIZE只是一个理论值，可能出于对JVM头信息存储的考虑而设计 * 因为在hugeCapacity 方法中 minCapacity &amp;gt; MAX_ARRAY_SIZE) ?</description>
    </item>
    
    <item>
      <title>Thread Run Method Execution Process Tracking and Thinking</title>
      <link>https://jordonyang.github.io/post/thread-run-method-execution-process-tracking-and-thinking/</link>
      <pubDate>Sun, 25 Mar 2018 21:46:51 +0800</pubDate>
      
      <guid>https://jordonyang.github.io/post/thread-run-method-execution-process-tracking-and-thinking/</guid>
      <description>前言 之前听到很多说法都是:“单纯地执行Thread子类的run方法并没有多线程的效果，正确的做法是，用Thread子类对象执行Thread的start方法，这样start方法会自动执行子类的run方法。” 我对这种神奇的说法将信将疑，心里总感觉不踏实，于是点进Thread的源码了解了一下。
一. 入坑过程 然而，纵观 start 方法，并没有找到 run 这个词，那run方法又是在哪里被调用的呢？其中最有嫌疑的地方就是native方法start0。
Thread 类有个 registerNatives 本地方法，该方法主要的作用就是注册一些本地方法供 Thread 类使用，如 start0()，stop0() 等等，可以说，所有操作本地线程的本地方法都是由它注册的。这个方法放在一个静态代码块中，当 Thread 类被加载到 JVM 中的时候，它就会被调用，进而注册相应的本地方法。 而本地方法 registerNatives 是定义在 openjdk\jdk\src\share\native\java\lang\Thread.c文件 中的。Thread.c 是个很小的文件，它定义了各个操作系统平台都要用到的关于线程的公用数据和操作，如下：
可以容易的看出 Java 线程调用start-&amp;gt;start0的方法，实际上会调用到 JVM_StartThread 方法，而 JVM_StartThread 方法则是在openjdk\hotspot\src\share\vm\prims\jvm.cpp中定义的
JVM_ENTRY 作为一个宏，用来定义 JVM_StartThread 函数，可以看到函数内创建了真正的平台相关的本地线程，其线程函数是 thread_entry，如下：
可见其中调用了 vmSymbols::run_method_name 方法， 而 run_method_name 是在 openjdk\hotspot\src\share\vm\classfile\vmSymbols.hpp 中用宏定义的：
这样不难想象到执行 Thread.start() 后的底层调用过程
二. 拓展 理解到 statrt0 方法为我们做了哪些事情后就很容易理解Java中线程启动的大致过程。
1. Thread子类 任务类继承Thread类，并覆盖它的run方法
当 subThread 调用父类的start方法时，由上面的过程可以知道，在JVM申请CPU线程资源并开启线程后，会执行 Thread类 的 run 方法,而由于JVM多态支持，最终调用的是 SubThread 的 run 方法，从而实现在一个线程中完成任务。</description>
    </item>
    
    <item>
      <title>Understanding the Foreach Syntax Sugar by Decompilation</title>
      <link>https://jordonyang.github.io/post/understanding-the-foreach-syntax-sugar-by-decompilation/</link>
      <pubDate>Sun, 25 Feb 2018 22:03:56 +0800</pubDate>
      
      <guid>https://jordonyang.github.io/post/understanding-the-foreach-syntax-sugar-by-decompilation/</guid>
      <description>前言 最近一直在看TiJ，在持有对象那章，Bruce Eckel说到Collection的内容可以用foreach遍历，原因是Java SE%引入了Iterable接口，该接口包含一个能够产生Iterator的iterator方法，并且Iterable接口被foreach用来在序列中移动。因此任何Iterable的实现类都可以用于foreach语句。那么我们在尝着这一语法糖的甜头时，JDK底层帮我们做了哪些事情呢？
实验 环境：IntelliJ IDEA 2018.1、jdk1.7.0_80
下面例子的Java代码中使用了两个foreach分别遍历数组和ArrayList：
package reversecompile; import java.util.ArrayList; import java.util.List; public class TestForEach { public static void main(String[] args) { String[] arr = &amp;quot;I am a coder&amp;quot;.split(&amp;quot; &amp;quot;); List&amp;lt;String&amp;gt; strings = new ArrayList&amp;lt;&amp;gt;(); for (String s : arr){ strings.add(s); System.out.println(s); } for (String s : strings){ System.out.println(s); } } }  通过IDEA反编译后的·TestForEach.class：
// // Source code recreated from a .class file by IntelliJ IDEA // (powered by Fernflower decompiler) // package reversecompile; import java.</description>
    </item>
    
    <item>
      <title>Constructing Binary Heap with Java</title>
      <link>https://jordonyang.github.io/post/constructing-binary-heap-with-java/</link>
      <pubDate>Mon, 25 Sep 2017 22:32:08 +0800</pubDate>
      
      <guid>https://jordonyang.github.io/post/constructing-binary-heap-with-java/</guid>
      <description>前言 最近在看《算法导论》，从中感受到了算法世界的神奇，看完二叉堆后觉得实现起来应该不难，所以试着根据书中的伪代码用Java实现一遍。
概念 基本定义 二叉堆是一个数组，可近似看成完全二叉树，表示堆的数组A通常包含两个属性：A.length（数组长度）和A.heap-size（堆的有效元素）
private int[] heap; private int heapSize; public MyHeap(int[] array) { this.heap = array; this.heapSize = array.length; }  通过下标定位亲属节点 由于堆可看做完全二叉树，所以可以通过某节点的下标获取其左右子节点和父节点
private int left(int i) { return 2 * i + 1; } private int right(int i) { return 2 * i + 2; } private int parent(int i) { return (i - 1) / 2; }  堆的一些性质  最大堆性质：A[PARENT[i] &amp;gt;= A[i]] 最小堆性质：A[PARENT[i] &amp;lt;= A[i]] 含有n个元素的堆的高为：小于等于lgn的最大整数 当用数组表示存储了n个元素的堆时，叶节点下标分别为 (n/2) + 1, (n / 2) + 2, &amp;hellip;, n（下标从１开始）  维持堆的性质 使下标为i的节点所构成的堆成为最大堆</description>
    </item>
    
  </channel>
</rss>